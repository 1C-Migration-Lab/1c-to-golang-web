Ниже приведён **пример** технического задания (**ТЗ**) для написания **программы**, которая будет **автоматически** (или полуавтоматически) **переводить** произвольную конфигурацию 1С (с исходными данными в XML-файлах) в веб-стек: **HTML + JavaScript** (клиентский код и формы) + **Go** (серверный код). При этом в качестве **языка разработки** данного инструмента предполагается **Python**, а там, где потребуется «ручное» вмешательство при переходе между высокоуровневыми абстракциями, используется **проприетарная LLM** (large language model). Существующие парсеры для AST уже имеются; также есть готовый перевод XML-форм 1С в HTML (без JavaScript), который не нужно писать с нуля.

ТЗ будет корректироваться, все предложения через Issues/PR приветствуются

---

## 1. Цель проекта

Разработать утилиту/программу на **Python**, которая сможет:

1. **Принимать** на вход **произвольную** выгрузку **конфигурации 1С** (формат XML + тексты модулей в CDATA, а также структура директорий после `v8unpack` или аналогичных инструментов).  
2. **Извлекать** из неё:
   - Метаданные объектов (Справочники, Документы, Регистры, Формы).  
   - Исходный код модулей (BSL).  
3. **Анализировать** и **трансформировать** полученные данные, чтобы в итоге:
   - Сформировать **Go-проекты** (backend) со схемой данных (таблицы, структуры), методами, CRUD-операциями, логикой, аналогичной процедурам 1С.  
   - Сформировать **HTML+JS**-формы (frontend) из XML-форм 1С (основываясь на уже имеющемся механизме XML→HTML).  
   - **Полуавтоматически** переводить «высокоуровневые» аспекты (переход от архитектуры конфигурации к полноценной предметной модели) при помощи LLM (для «смысловой» обработки).  

Итоговая программа должна **минимизировать ручные правки** при миграции логики 1С в веб-стек, но при этом **позволять** (где нужно) «спросить» LLM или использовать ручной ввод, чтобы уточнить непонятные участки кода/метаданных.

---

## 2. Общая концепция решения

С опорой на **«уровни абстракции»** (1–10) мы разделим задачу на этапы:

1. **Чтение конфигурации (XML)**  
   - Сканировать структуру директорий, собирать файлы описание метаданных и тексты модулей (в CDATA).  
   - Парсить XML, извлекать реквизиты, типы, связи.  
2. **Построение AST** (уровень 4) для **модулей** (BSL-кода)  
   - Использовать **готовые парсеры** (например, `bsl-parser` через Python).  
   - На выходе — **абстрактное синтаксическое дерево** (AST) для каждой процедуры/функции/оператора.  
3. **Code Model / IR** (уровень 5)  
   - На базе AST и информации о метаданных (к какому объекту 1С относится модуль) формируем «промежуточное представление»:  
     - Какие есть объекты (Документ, Справочник), их модули (Объект/Менеджер/Форма), какие процедуры, какие вызовы, какие обращения к регистрам/табличным частям.  
4. **Dependency Graph** (уровень 6) — опционально, но полезно  
   - Отобразить, кто кого вызывает (документ «Х» вызывает регистр «Y»), чтобы понимать связи.  
5. **Архитектурный / Функциональный уровень** (7)  
   - Автоматически собрать «скелет» структуры: вот Справочники, вот Документы, ТЧ, регистры и т.д.  
6. **(Переход к) Domain Model** (8) при помощи **LLM**  
   - Здесь нужна **«ручная»** (или «полуавтоматическая») проработка:  
     - На основе русских/англ. наименований (например, «ЗаказПокупателя», «Контрагенты»…) и кодовой логики система **предлагает**: «Возможно, это сущность “Order”, “Client”».  
     - LLM (проприетарная) или пользователь **подтверждает**/корректирует.  
   - Результат: более осмысленная модель для **генерации** Go-структур (Order, OrderItem, Client...).  
7. **Генерация Go-кода** (backend)  
   - Автоматически для каждого объекта 1С (с учётом Domain Model) создавать:  
     - Структуры Go (struct) для хранения данных (реквизиты, табличные части).  
     - Методы, отражающие логику из модуля (например, `func (o *Order) Recalculate(){ ... }`) на базе AST/IR.  
   - Генерация маршрутов (REST) или других точек входа (CRUD) по модели.  
8. **Генерация HTML+JS** (frontend)  
   - **XML-формы** 1С уже **переводятся** в HTML при помощи **готового** парсера (его внедрять не требуется).  
   - В коде **JS** (или React/Vue) можно автоматически встраивать логику пересчёта (если, например, в 1С-процедуре «ПриИзменении» табличной части пересчитываем суммы).  
   - Там, где требуется бизнес-смысл, можно так же спросить LLM, чтобы «украсить» UI или добавить «умные» подсказки.  

Результат — некий набор **проектных артефактов** (Go backend + HTML/JS фронтенд), который **концептуально** повторяет функционал исходной конфигурации 1С.

---

## 3. Подробные требования к функциональности

1. **Парсинг XML (метаданные)**  
   - Программа на Python читает файлы `Description.xml` для каждого объекта (Document, Catalog, Register, Form), извлекает:  
     - Название (Name)  
     - Тип объекта (Document, Catalog, AccumulationRegister, etc.)  
     - Реквизиты (Properties), Табличные части (TabularSections), их поля, типы (Number, String, Reference...), формы.  
   - Формирует внутренние структуры (словарь или классы Python) с информацией об объектах.

2. **Парсинг кода BSL (ObjectModule, ManagerModule…)**  
   - Для каждого модуля, извлечённого из `<![CDATA[ ... ]]>`, вызывается **готовый AST-парсер**.  
   - Программа хранит результат в удобном формате (JSON или Python-объекты).

3. **Связывание (Code Model + Архитектура)**  
   - Сопоставить: «Этот модуль относится к Документу “X” (ObjectModule), внутри модуля есть процедуры “ПриЗаписи” и “ПриПроведении”».  
   - Записать вызовы (например, `Движения.ИмяРегистра.Добавить()` -> «Запись в Регистр “ИмяРегистра”»).  

4. **Генерация IR** для дальнейшей трансляции  
   - Для каждой процедуры AST → удобный IR: «ForEach (ТабЧасть “Товары”) → Присвоить (СуммаСтроки = Количество*Цена) → …»  
   - Сохраняем детали (операции, циклы, вызовы).  

5. **Обработка «высоких» смыслов** (от Архитектуры (7) к Domain Model (8))  
   - **«Вызов»** проприетарной LLM (или пользовательского интерфейса) для уточнения названий, терминов, назначения (например, «Определить, что Document “ЗаказПокупателя” = “Order” в будущем Go-коде»).  
   - Программа должна уметь **интерактивно** (через CLI или веб-интерфейс) спрашивать: «Как назвать структуру? Как назвать поля?» и т.д.

6. **Генерация Go-кода**  
   - На основе итоговой «Domain Model» (например, Order / OrderItems) и IR.  
   - Генерировать `.go` файлы:  
     - Структуры для сущностей (с учётом типов).  
     - Методы (например, `Recalculate`) из логики 1С.  
     - CRUD-доступ к БД (миграции SQL/ORM, REST endpoints).  

7. **Генерация HTML+JS**  
   - Использовать **уже имеющийся** парсер, который умеет переводить XML-формы 1С → HTML (без JS).  
   - Дополнить процесс автоматическим формированием JS для «динамической логики» (обработчики событий формы, пересчёты и т.д.), используя AST-IR.  
   - При необходимости обратиться к LLM для «украшения» кода, если стоит цель улучшить UX.

8. **Выходные артефакты**  
   - **Каталог** с Go-кодом (backend).  
   - **Каталог** с HTML-страницами (и JS-файлами) (frontend).  
   - При желании — Dockerfile, скрипты сборки и т.п.  

---

## 4. Технологические требования

1. **Основной язык разработки** инструмента: **Python** 3.XX.  
2. **Парсеры**:  
   - Готовый **BSL-parser** (через Python, либо вызовы CLI) для получения AST 1С.  
   - Готовый **XML→HTML** модуль для переводов форм — включить в pipeline, **не нужно** писать с нуля.  
3. **LLM**: проприетарная модель для «семантических» вопросов, доступ через API или локальный сервис.  
4. **Версии**:  
   - Целевой Go — 1.18+ (или актуальная).  
   - HTML/JS — современный ES6+.  
5. **Формат хранения** промежуточных данных (IR, архитектура) — по согласованию (JSON, YAML, Python-объекты).  

---

## 5. Моменты, требующие ручного вмешательства

1. **Семантические переименования**: определить, что «ЗаказПокупателя» = «Order», «Контрагенты» = «Clients» и т.п.  
2. **Сложные кейсы**: нестандартные схемы, когда логика 1С зависит от глобального контекста, обращений к внешним источникам, механизмы «Планов обмена» и т.п.  
3. **Доработка UI**: если после XML→HTML хочется улучшить интерфейс (верстку, JS), часть может остаться ручной.

Для подобных шагов программа будет вызывать LLM (или ждать ввода пользователя) и затем продолжать генерацию кода.

---

## 6. Приёмка и критерии готовности

1. **Демонстрация**: запустить утилиту на **тестовой** конфигурации 1С (например, «Мини Заказы»).  
2. **Результат**: в выходных папках появляются:  
   - Проект на Go (файлы `.go`) со структурами и методами (распознанными из 1С-модулей).  
   - HTML-файлы форм (полученные через XML→HTML-parser) с базовым JS для пересчёта (если есть логика).  
   - SQL-схема или миграции (при необходимости) для хранения соответствующих сущностей.  
3. **Минимум ручных правок**: подтверждаем, что большинство логики (например, «СуммаСтроки = Количество * Цена») перенесено корректно без посторонних действий.  
4. **Отчёт**: какие места потребовали вмешательства (и как программа взаимодействует с LLM).  

---

## 7. Формат сдачи и документация

1. **Исходный код** утилиты (Python), инструкция по запуску (README).  
2. **Описание** структуры IR, куда складывается AST, как хранится информация о метаданных.  
3. **Пример** конфигурационного файла (YAML/JSON), где указываются пути к выгрузке 1С, настройки LLM, пути для Go-кода и HTML.  
4. **Демонстрационный кейс** (например, та же «Мини Заказы»), в котором показываются все этапы: запуск -> вопросы модели -> генерация Go+HTML -> результат.

---

### Заключение

Таким образом, **ТЗ** требует **разработать** программу на **Python**, которая:

- **Считывает** и **разбирает** конфигурацию 1С (XML и BSL).  
- **Преобразует** модули (AST, IR) и объекты метаданных (документы/справочники/регистры) в **Go** (бэкенд) + **HTML/JS** (фронтенд).  
- **Учитывает** моменты, где необходимо **ручное** или **полуавтоматическое** вмешательство — с использованием проприетарной **LLM** для «семантической» части (переход от архитектуры 1С к бизнес-доменной модели).  
- Использует **уже имеющийся** модуль перевода XML-форм 1С в HTML, не разрабатывая его с нуля.

Цель — **минимизировать** ручной труд при портировании логики 1С в веб-приложение и обеспечить **структурированный** процесс миграции.